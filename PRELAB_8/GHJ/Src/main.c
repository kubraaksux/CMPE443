/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>


typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFRL;
	volatile uint32_t AFRH;
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
  volatile uint32_t CR1;
  volatile uint32_t CR2;
  volatile uint32_t SMCR;
  volatile uint32_t DIER;
  volatile uint32_t SR;
  volatile uint32_t EGR;
  volatile uint32_t CCMR1;
  volatile uint32_t CCMR2;
  volatile uint32_t CCER;
  volatile uint32_t CNT;
  volatile uint32_t PSC;
  volatile uint32_t ARR;
  volatile uint32_t RCR;
  volatile uint32_t CCR1;
  volatile uint32_t CCR2;
  volatile uint32_t CCR3;
  volatile uint32_t CCR4;
  volatile uint32_t BDTR;
  volatile uint32_t DCR;
  volatile uint32_t DMAR;
  volatile uint32_t OR1;
  volatile uint32_t CCMR3;
  volatile uint32_t CCR5;
  volatile uint32_t CCR6;
  volatile uint32_t OR2;
  volatile uint32_t OR3;
} TIM_TypeDef;


#define TIM4  ((TIM_TypeDef *) 0x40000800)
#define TIM15  ((TIM_TypeDef *) 0x40014000)


#define NVIC_ISER1  *((volatile uint32_t *) 0xE000E104)
#define NVIC_ISER2  *((volatile uint32_t *) 0xE000E108)


#define NVIC_ICER1  *((volatile uint32_t *) 0xE000E184)

#define GPIOA ((GPIO_TypeDef *)  0x42020000)
#define GPIOB ((GPIO_TypeDef *)  0x42020400)
#define GPIOC ((GPIO_TypeDef *)  0x42020800)



#define RCC_AHB2ENR   *((volatile uint32_t *) 0x4002104C)
#define RCC_APB1ENR   *((volatile uint32_t *) 0x40021058)
#define RCC_APB2ENR   *((volatile uint32_t *) 0x40021060)


#define HI 1
#define LO 0
static uint16_t edgefirst, pulsewidth;

void TIM4_IRQHandler(void)  // input mode PB6 AF2
{
   static unsigned int ic_pin=LO;
   TIM4->SR = 0;

   if(ic_pin==LO)//HI has come
   {
	   ic_pin=HI;
	   edgefirst = TIM4->CCR1;

   }
   else //LO has come
   {
	   ic_pin=LO;
	   pulsewidth= TIM4->CCR1-edgefirst;
	   TIM15->CNT = TIM15->CCR1;

   }
}


void TIM15_IRQHandler(void){ // output mode  PA2 AF14

	TIM15->SR =0;

	TIM15->CCR1 += pulsewidth;

}

int main(void) {
	//Enable Clock for GPIO
	RCC_AHB2ENR |= (1 << 0); // gpioA clock active
	RCC_AHB2ENR |= (1 << 1); // gpioB clock active
	RCC_AHB2ENR |= (1 <<2); // gpioc clock active

	GPIOC->MODER &= ~(3<<14);
	GPIOC->MODER |= 1<<14;



	RCC_APB1ENR |= (1<<2);  // tim 4 clock active
	RCC_APB2ENR |= (1<<16);	// tim 5 clock active



	//Configure Pin as General purpose output mode
	GPIOB->MODER |= (1 << 13); 	// PB6 ALTERNATE mode
	GPIOB->MODER &= ~(1 << 12);

	GPIOA->MODER |= (1 << 5);	// pA2 ALTERNATE mode
	GPIOA->MODER &= ~(1 << 4);

	GPIOB->AFRL &= ~(15 << 24);	    // PB6 AF2
	GPIOB->AFRL |= (2<<24);
	GPIOA->AFRL &= ~(15 << 8);			// PA2 AF14
	GPIOA->AFRL |= (14<<8);


	// tim4 initialize (red)
	NVIC_ISER1 |= (0x01<<15);	// Enable IRQ for Timer
	TIM4->SR =0 ;
	TIM4->DIER |= (0x01<<1);  	// capture compare interrupt enable,,, Enable capture interrupt
	TIM4->CCMR1 &= ~3;			// select input capture
	TIM4->CCMR1 |= 1;			// Configure timer channel for input capture
	TIM4->CCER  |= 1;			// capture compare enable
	TIM4->CCER  |= 1<<1;		// listen both edges
	TIM4->CCER  |= 1<<3;		// listen both edges
	TIM4->PSC = 7999; 		// Configure prescaler to increase the CNT register for every 2 millisecond. (PSC)
	TIM4->CR1 |= 0x01;		// timer counterını başlat


	// tim15 initialize (green)
	NVIC_ISER2 |= (0x01<<5); // Enable IRQ for Timer
	TIM15->SR = 0;
	TIM15->DIER |= (0x01<<1);  	// capture compare interrupt enable,, Enable output compare interrupt
	TIM15->BDTR |= 1<<15;		// main output enable
	TIM15->CCMR1 &= ~3; 		// select output compare,, Configure timer channel for output compare
	TIM15->CCMR1 |= 3<<4;		// output toggle,, Configure timer channel for toggle
	TIM15->CCER  |= 1;			// capture compare enable
	TIM15->PSC = 19999; 		// Configure prescaler to increase the CNT register for every 5 millisecond
	TIM15->CR1 |= 0x01;		// timer counterını başlat






	__asm volatile( //enable all interrupts that are configured
	 "mov r0, #0 \n\t"
	 "msr primask, r0 \n\t"
	 );

}



