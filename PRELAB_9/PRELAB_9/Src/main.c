/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>


typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFRL;
	volatile uint32_t AFRH;
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
  volatile uint32_t CR1;
  volatile uint32_t CR2;
  volatile uint32_t SMCR;
  volatile uint32_t DIER;
  volatile uint32_t SR;
  volatile uint32_t EGR;
  volatile uint32_t CCMR1;
  volatile uint32_t CCMR2;
  volatile uint32_t CCER;
  volatile uint32_t CNT;
  volatile uint32_t PSC;
  volatile uint32_t ARR;
  volatile uint32_t RCR;
  volatile uint32_t CCR1;
  volatile uint32_t CCR2;
  volatile uint32_t CCR3;
  volatile uint32_t CCR4;
  volatile uint32_t BDTR;
  volatile uint32_t DCR;
  volatile uint32_t DMAR;
  volatile uint32_t OR1;
  volatile uint32_t CCMR3;
  volatile uint32_t CCR5;
  volatile uint32_t CCR6;
  volatile uint32_t OR2;
  volatile uint32_t OR3;
} TIM_TypeDef;

typedef struct
{
  volatile uint32_t ISR;
  volatile uint32_t IER;
  volatile uint32_t CR;
  volatile uint32_t CFGR;
  volatile uint32_t CFGR2;
  volatile uint32_t SMPR1;
  volatile uint32_t SMPR2;
  volatile uint32_t REZ0;
  volatile uint32_t TR1;
  volatile uint32_t TR2;
  volatile uint32_t TR3;
  volatile uint32_t REZ1;
  volatile uint32_t SQR1;
  volatile uint32_t SQR2;
  volatile uint32_t SQR3;
  volatile uint32_t SQR4;
  volatile uint32_t DR;

} ADC_TypeDef;

#include <stdint.h>


#define GPIOA ((GPIO_TypeDef *) 0x42020000)
#define GPIOB ((GPIO_TypeDef *) 0x42020400)
#define GPIOC ((GPIO_TypeDef *) 0x42020800)
#define ADC   ((ADC_TypeDef *)  0x42028000)



#define RCC_AHB2ENR *((volatile uint32_t *)(0x4002104C))
#define RCC_CCIPR1  *((volatile uint32_t *)(0x40021088))
#define NVIC_ISER1 *((volatile uint32_t *) 0xE000E104)


void ADC1_2_IRQHandler() {


	uint32_t val = ADC->DR;

	if(val<=4096 * 0.25 ){


		GPIOA->ODR &= ~(1<<9); //red off
		GPIOB->ODR &= ~(1<<7);	//blue off
		GPIOC->ODR &= ~(1<<7);	//green off



	}else if(val<=4096 * 0.5){

		GPIOB->ODR |= 1<<7;	//blue on
		GPIOA->ODR &= ~(1<<9); //red off
		GPIOC->ODR &= ~(1<<7);	//green off
	}else if( val<=4096 * 0.75){


		GPIOB->ODR |= 1<<7;	//blue on
		GPIOA->ODR &= ~(1<<9); //red off
		GPIOC->ODR |= 1<<7;	//green on

	}else{
		GPIOA->ODR |= 1<<9; //red on
		GPIOB->ODR |= 1<<7;	//blue on
		GPIOC->ODR |= 1<<7;	//green on

	}

	ADC->CR |= (1<<2);
}


int main(void) {
	//Enable Clock for GPIO

	RCC_AHB2ENR |= 1; //gpioA clock active
	RCC_AHB2ENR |= 1<<1; //gpioB clock active
	RCC_AHB2ENR |= 1<<2; //gpioC clock active

	GPIOA->MODER &= ~(1<<19); //red (PA9)
	GPIOA->MODER |= (1<<18);
	GPIOB->MODER &= ~(1<<15); //blue (PB7)
	GPIOB->MODER |= (1<<14);
	GPIOC->MODER &= ~(1<<15); //green (PC7)
	GPIOC->MODER |= (1<<14);

	//Enable Clock for ADC

	RCC_AHB2ENR |= (1<<13);


	//Select ADC clock as System clock

	RCC_CCIPR1 |= (3<<28);


	//Change Pin Mode to Analog

	GPIOA->MODER |= 3;


	//Change Pin Pull/Down to no pull-up no pull-down

	GPIOA->PUPDR &= ~(0x03);


	//Change Regular channel sequence length to 1 conversion

	ADC->SQR1 &= ~(15);




	//Add to channel to first sequence

	ADC->SQR1 |= (0x05<<6);  ////sqr pa 0Ä±n channeli 5

	//sqr


	//Enable ADC Voltage regulator


	ADC->CR &= ~(1<<29);

	//Disable Deep-power-down for ADC


	ADC->CR |= (1<<28);





	//Configure for Single conversion mode

	ADC->CFGR &= ~(1<<13);


	//Enable ADC

	ADC->CR |= 1;


	//Wait ADC is enabled

	while(!(ADC->ISR &1));





	//Enable interrupt for end of regular conversion
	ADC->IER |= (1<<2);

	NVIC_ISER1 |= (0x01<<5);// Enable IRQ for ADC


	//Start regular conversion of ADC

	ADC->CR |= (1<<2);

}






































