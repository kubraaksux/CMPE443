/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFR[2];
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
  volatile uint32_t CR1;
  volatile uint32_t CR2;
  volatile uint32_t SMCR;
  volatile uint32_t DIER;
  volatile uint32_t SR;
  volatile uint32_t EGR;
  volatile uint32_t CCMR1;
  volatile uint32_t CCMR2;
  volatile uint32_t CCER;
  volatile uint32_t CNT;
  volatile uint32_t PSC;
  volatile uint32_t ARR;
  volatile uint32_t RCR;
  volatile uint32_t CCR1;
  volatile uint32_t CCR2;
  volatile uint32_t CCR3;
  volatile uint32_t CCR4;
  volatile uint32_t BDTR;
  volatile uint32_t DCR;
  volatile uint32_t DMAR;
  volatile uint32_t OR1;
  volatile uint32_t CCMR3;
  volatile uint32_t CCR5;
  volatile uint32_t CCR6;
  volatile uint32_t OR2;
  volatile uint32_t OR3;
} TIM_TypeDef;



#define RCC_AHB2ENR *((volatile uint32_t *) (0x40021000 + 0x4C)) // gpioa enable
#define RCC_APB1ENR *((volatile uint32_t *) (0x40021000 + 0x058)) // RCC base adress + RCC_APB1ENR offset

#define GPIOA			((GPIO_TypeDef *)	0x42020000) // GPIOA okay
#define TIM6           ((TIM_TypeDef *)	 0x40001000)  // TIM6 peripheral base adress
uint32_t timer_value = 0;

int main(void) {
	RCC_AHB2ENR |= 1 << 0; // gpioa clock enabled

	GPIOA->MODER &= ~(0x03 << (9 * 2));  // red led pa9 . pa9 output.
	GPIOA->MODER |= (0x01 << (9 * 2));  // output 01

	// echo'yu bağlamak için bir pin seç. input yap.

	GPIOA->MODER &= ~(0x03 << (0 * 2)); // pa0 input


	// trigger'ı bağlamak için bir pin seç. output yap.

	GPIOA->MODER &= ~(0x03 << (1 * 2));  // pa1 output
	GPIOA->MODER |= (0x01 << (1 * 2));



	RCC_APB1ENR |= (1 << 4); // enable tim6

	TIM6->PSC = 4 - 1; // tim6 ya 4MHz sinyal geliyor. bu registera verdiğin. 4MHz/değer
	TIM6->CR1 |= (0x01); // okay. timer'ın saymasını başlatıyor.


	while(1) {

		TIM6->SR &= ~(1<<0); // // sr  0.bit 0
		// trigger başlat. triggger output 1 ver

		GPIOA->ODR |= (1<<1);

		//  arr yi 2^16-1 (??)

		TIM6->ARR = 10;

		while(!(TIM6->SR & 1));
		// sr nin 0.biti 1 olana kadar bekle. yani overflow olana kadar bekle

		// trigger ı 0 la
		GPIOA->ODR &= ~(1<<1);

		//echo 0 ken bekle
		while(!( GPIOA->IDR & 1));
		// start time
		TIM6->ARR = 0xFFFF;  // (?)
		timer_value = TIM6->CNT;
		// echo 1 ken bekle
		while( GPIOA->IDR & 1);
		// end time
		// start ile end arasındaki fark bir ses dalgasının 10 cm yi gidip dönme süresinden azsa red ledi yak. çoksa red ledi söndür.

		if(TIM6->CNT - timer_value < 583){
		GPIOA->ODR |= 1<<9;
		}else{
			GPIOA->ODR &= ~(1<<9);
		}

		//delay
		timer_value = TIM6->CNT;
		while(TIM6->CNT - timer_value < 0XFFFF);


	}
}
